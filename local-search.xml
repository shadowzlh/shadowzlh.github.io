<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>七大设计模式原则</title>
    <link href="/2023/08/30/%E4%B8%83%E5%A4%A7%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8E%9F%E5%88%99/"/>
    <url>/2023/08/30/%E4%B8%83%E5%A4%A7%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8E%9F%E5%88%99/</url>
    
    <content type="html"><![CDATA[<h2 id="1-单一原则-SRP"><a href="#1-单一原则-SRP" class="headerlink" title="1. 单一原则(SRP)"></a>1. 单一原则(SRP)</h2><blockquote><p>单一职责原则 : Single Responsibility  principle </p></blockquote><p>它要求<strong>一个类或者模块应该只负责一个特定的功能,</strong> 这有助于降低类之间的耦合度, 提高代码的可读性和了维护性</p><p>单一职责原则反例 : </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-comment">// Getter 和 Setter 方法</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">sayHi</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 计算员工工资的逻辑</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hi&quot;</span> + <span class="hljs-built_in">this</span>.name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getUserById</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 根基 id 获得用户</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>一个用户的实体应该围绕着他的本身进行实现方法, 在这个类中, 这里包括了和这个类无关的逻辑</p><h4 id="类的职责是确定的吗"><a href="#类的职责是确定的吗" class="headerlink" title="类的职责是确定的吗 ?"></a>类的职责是确定的吗 ?</h4><p>有的类的单一职责是有时候是很难确定的,  需要根据业务视情况而定</p><h4 id="类的职责是否越单一越好"><a href="#类的职责是否越单一越好" class="headerlink" title="类的职责是否越单一越好 ?"></a><strong>类的职责是否越单一越好 ?</strong></h4><p>不是 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Serialization</span>  &#123;<br>    <span class="hljs-keyword">private</span> String type;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">serialize</span><span class="hljs-params">(Object obj)</span> &#123;<br>        <span class="hljs-comment">// 使用type 方式序列化 obj</span><br>    &#125;<br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">deserialize</span><span class="hljs-params">(String text)</span> &#123;<br>        <span class="hljs-comment">// 使用type类型反序列化 text</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以将这个类拆分为两个独立的部分 : 1. 序列化 2. 反序列化</p><p>但是当我们拆分之后, 则两个职责就失去了一个沟通的桥梁, 拆分之后还</p><h2 id="2-开闭原则"><a href="#2-开闭原则" class="headerlink" title="2. 开闭原则"></a>2. 开闭原则</h2><blockquote><p>开闭原则: Open Closed Principle</p></blockquote><p>开闭原则简单来说就是: <strong>对扩展开放, 对修改关闭</strong></p><p>当我们要新增加一个功能时, 不需要去修改原有的代码</p><p>比如 当我们需要替换 SpringBoot 的默认日志实现的时候, 我们不需要去更改代码, 我们只需要增加一个pom 依赖就可以</p><h4 id="开闭原则是一点代码都不去修改吗"><a href="#开闭原则是一点代码都不去修改吗" class="headerlink" title="开闭原则是一点代码都不去修改吗 ?"></a>开闭原则是一点代码都不去修改吗 ?</h4><p>开闭原则是要求我们尽量去减少对原有代码的修改</p><p>我们无法做到真的不去修改代码</p><p>当我们对当当前的功能上进行适当的改进的时候, 也可以说是遵循了开闭原则</p><h4 id="如何践行开闭原则"><a href="#如何践行开闭原则" class="headerlink" title="如何践行开闭原则 ?"></a>如何践行开闭原则 ?</h4><p>为了更好的去实现开闭原则, 我们需要将可变的部分封装为一个独立的模块, 然后找寻这些模块共同的部分, 抽象出一个公共的部分,.  尽量屏蔽上层对下层的强依赖</p><p>有以下几种实现方式 :</p><ul><li>抽象和封装</li><li>依赖注入</li><li>使用设计模式</li><li>使用事件机制</li><li>使用插件</li><li>使用消息</li></ul><h2 id="3-里氏替换原则"><a href="#3-里氏替换原则" class="headerlink" title="3. 里氏替换原则"></a>3. 里氏替换原则</h2><blockquote><p>里式替换原则: Liskov Substitution Principle</p></blockquote><p>通俗来说 : <strong>子类对象能够替换程序中父类对象出现的任何地方，并且保证原来程序的逻辑行为不变及正确性不被破坏。</strong></p><p>实例 : 对于接口的实现 : </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 飞行行为接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Flyable</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">fly</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">// 基类：鸟类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Bird</span> &#123;<br>&#125;<br><br><span class="hljs-comment">// 子类：能飞的鸟类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FlyingBird</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Bird</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Flyable</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fly</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;I can fly&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 子类：企鹅类，不实现Flyable接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Penguin</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Bird</span> &#123;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>反例的特征</p><ol><li><p>覆盖了父类的方法</p></li><li><p>对父类添加了新的约束 比如 单调栈对于栈来说就增加了一个约束</p></li><li><p>子类与基类之间缺乏 “ is-a”关系( 子类是一个基类)</p></li></ol><h2 id="4-接口隔离原则"><a href="#4-接口隔离原则" class="headerlink" title="4. 接口隔离原则"></a>4. 接口隔离原则</h2><blockquote><p>接口隔离原则: Interface Segregation Principle</p></blockquote><p>接口隔离原则: <strong>客户端不应该强迫依赖它不需要的接口。</strong></p><p>此外它还有一个定义 : <strong>一个类对另一个类的依赖应该建立在最小的接口上</strong></p><p>这要求程序员尽量将臃肿庞大的接口拆分成更小的和更具体的接口</p><h4 id="接口隔离原则的优点"><a href="#接口隔离原则的优点" class="headerlink" title="接口隔离原则的优点 ?"></a>接口隔离原则的优点 ?</h4><ol><li>将臃肿庞大的接口分解为多个粒度小的接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。</li><li>接口隔离提高了系统的内聚性，减少了对外交互，降低了系统的耦合性。</li><li>如果接口的粒度大小定义合理，能够保证系统的稳定性；但是，如果定义过小，则会造成接口数量过多，使设计复杂化；如果定义太大，灵活性降低，无法提供定制服务，给整体项目带来无法预料的风险。</li><li>使用多个专门的接口还能够体现对象的层次，因为可以通过接口的继承，实现对总接口的定义。</li><li>能减少项目工程中的代码冗余。过大的大接口里面通常放置许多不用的方法，当实现这个接口的时候，被迫设计冗余的代码。</li></ol><p>反例 : </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">action</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">fly</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">walk</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">say</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">look</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>当一个动物如果想要行动, 就需要实现里面的全部接口, 有的是完全没有必要的, 比如狗的没有fly 的动作的</p><p>所以这个action 的粒度就偏大, 我们应该进行拆分</p><h2 id="5-依赖倒置原则"><a href="#5-依赖倒置原则" class="headerlink" title="5. 依赖倒置原则"></a>5. 依赖倒置原则</h2><blockquote><p>依赖倒置原则 : Dependency Inversion Principle</p></blockquote><p>依赖倒置原则 : <strong>要依赖于抽象而不是具体实现</strong></p><p>依赖倒置原则有两个关键点：</p><ul><li><strong>高层模块不应该依赖于低层模块，它们都应该依赖于抽象。</strong></li><li><strong>抽象不应该依赖于具体实现，具体实现应该依赖于抽象。</strong></li></ul><p>实例 : Ioc 容器  MVC 中的 <code>service intface </code> 、   <code>mapper intface</code></p><h2 id="6-合成-聚合复用原则"><a href="#6-合成-聚合复用原则" class="headerlink" title="6.  合成&#x2F;聚合复用原则"></a>6.  合成&#x2F;聚合复用原则</h2><blockquote><p>合成&#x2F;聚合复用原则 Composite&#x2F;Aggregate Reuse Principle</p></blockquote><p>成&#x2F;聚合复用原则就是在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分；新的对象通过向这些对象的委派达到复用已有功能的目的。</p><p>它的设计原则是：<strong>要尽量使用合成&#x2F;聚合，尽量不要使用继承。</strong></p><p><strong>聚合概念：</strong> </p><p>聚合用来表示“拥有”关系或者整体与部分的关系。代表部分的对象有可能会被多个代表整体的对象所共享，而且不一定会随着某个代表整体的对象被销毁或破坏而被销毁或破坏，部分的生命周期可以超越整体。</p><p>例如，Iphone5和IOS，当Iphone5删除后，IOS还能存在，IOS可以被Iphone6引用。</p><p><strong>合成概念：</strong> </p><p>合成用来表示一种强得多的“拥有”关系。在一个合成关系里，部分和整体的生命周期是一样的。一个合成的新对象完全拥有对其组成部分的支配权，包括它们的创建和湮灭等。</p><h4 id="组合与继承的区别"><a href="#组合与继承的区别" class="headerlink" title="组合与继承的区别 ?"></a>组合与继承的区别 ?</h4><p>在面向对象编程中，复用已有模块功能的方法有：组合与继承。</p><p>继承复用的特点：实现简单、易于扩展，破坏系统的封装性。从父类继承过来的实现是静态的，不可能通过运行时发生改变，没有足够的灵活性。</p><p>组合聚合复用：耦合度相对较低，选择性地调用成员对象操作，可以在运行时动态进行。</p><h2 id="7-迪米特法则-最少知识原则"><a href="#7-迪米特法则-最少知识原则" class="headerlink" title="7 . 迪米特法则 (最少知识原则)"></a>7 . 迪米特法则 (最少知识原则)</h2><blockquote><p>迪米特法则 Law of Demeter</p></blockquote><p>核心思想是：一个对象应该<strong>尽量少地了解其他对象，降低对象之间的耦合度</strong>，从而提高代码的可维护性和可扩展性。</p><p>简单来说就是 : <strong>两个类之间尽量不要直接依赖，如果必须依赖，最好只依赖必要的接口。</strong></p><p>因此，应用迪米特法则有可能造成的一个后果就是：系统中存在大量的中介类，这些类之所以存在完全是为了传递类之间的相互调用关系——这在一定程度上增加了系统的复杂度。</p><p>迪米特原则主要强调只和朋友交流，不和陌生人说话。</p><h4 id="那么，如何界定朋友？如何界定陌生人呢"><a href="#那么，如何界定朋友？如何界定陌生人呢" class="headerlink" title="那么，如何界定朋友？如何界定陌生人呢 ?"></a><strong>那么，如何界定朋友？如何界定陌生人呢</strong> ?</h4><p>迪米特法则指出，做为“朋友”的条件为：</p><ul><li>当前对象本身（this）；</li><li>被当做当前对象的方法的参数传入进来的对象；</li><li>当前对象的方法所创建或者实例化的任何对象；</li><li>当前对象的任何组件：被当前对象的实例变量引用的任何对象；</li><li>任何一个对象，如果满足上面的条件之一，就是当前对象的“朋友”，否则就是“陌生人”。</li></ul><p>假如你不认识你朋友 b 的朋友 c, 那你不要和 c 进行直接的沟通, 要经过 b 进行转达</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结 :"></a>总结 :</h2><p><strong>单一职责原则</strong>便是高内聚的基本思想；<strong>组合聚合原则</strong>来降低使用继承的强耦合性；<strong>迪米特法则</strong> 强调高内聚, 低耦合；<strong>接口隔离原则</strong>仍是体现高内聚思想；<strong>里氏替换原则</strong>、<strong>依赖倒置原则</strong>则助力实现高内聚弱耦合效果；<strong>开闭原则</strong>则是高内聚弱耦合的应用。</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
      <tag>七大原则</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>搭建自己的博客</title>
    <link href="/2023/08/26/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/"/>
    <url>/2023/08/26/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<p>最近越发的觉得, 自己应该记录一些自己平时的学习历程, 最主要是用来装一下 , 所以打算搭一个博客</p><p>本来是想使用 gitee 来搭建博客的, 但是搭建的过程中需要实名认证, 就放弃了, 转而使用 github</p><p>本文分为以下几个步骤: </p><ol><li>注册 github</li><li>创建仓库</li><li>安装 git</li><li>安装 nodejs</li><li>安装 hexo</li><li>更换 hexo 主题</li><li>绑定域名</li></ol><p>关于搭建图床的部分让我们放在下一篇博客中 ( 再水一篇 )</p><h2 id="1-注册-github-账号"><a href="#1-注册-github-账号" class="headerlink" title="1. 注册 github 账号"></a>1. 注册 github 账号</h2><p>此处太简单 略过</p><h2 id="2-创建仓库"><a href="#2-创建仓库" class="headerlink" title="2. 创建仓库"></a>2. 创建仓库</h2><p><img src="https://images.shadowzlh.top/2023/08/4501a7976972d25bc6c70dcac2b385ed.png" alt="仓库创建"></p><p><img src="https://images.shadowzlh.top/2023/08/7e95ed2cbd6fbf43e9ae08a2ec9f6a95.png" alt="仓库创建"></p><p>这里用户名要按照这个格式来 <code>用户名.github.io</code></p><p>选择 public</p><p>然后直接点击创建仓库就可以了</p><h2 id="3-安装-git"><a href="#3-安装-git" class="headerlink" title="3. 安装 git"></a>3. 安装 git</h2><p>​git 官方下载网站 :<a href="https://git-scm.com/downloads">Git - Downloads (git-scm.com)</a></p><p>​下载之后直接安装就可以</p><p>​之后我们就配置一下, 在桌面右键 选择 git bash</p><p><img src="https://images.shadowzlh.top/2023/08/728099d16b462b06bd0fdd46e5c96ad5.png" alt="git bash"></p><p>打开后</p><p>我们设置一下自己的用户名和密码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global user.name <span class="hljs-string">&quot;GitHub 用户名&quot;</span><br>git config --global user.email <span class="hljs-string">&quot;GitHub 邮箱&quot;</span><br></code></pre></td></tr></table></figure><p>之后我们创建一下 SSH 密钥</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh-keygen -t rsa -C <span class="hljs-string">&quot;GitHub 邮箱&quot;</span><br></code></pre></td></tr></table></figure><p>然后一直按回车就行</p><p>然后进入  <code>C:\Users\用户名\.ssh</code> 这个路径下</p><p><img src="https://images.shadowzlh.top/2023/08/eff80bac3d883761112818505f648612.png" alt="ssh 配置"></p><p>复制这个文件中的公钥</p><p><img src="https://images.shadowzlh.top/2023/08/6499e88d35a1024f009b86284a928492.png" alt="ssh 配置"></p><p><img src="https://images.shadowzlh.top/2023/08/ee3ff0773d86713cecab26800f1238b6.png" alt="ssh 配置"></p><p>在title 中随便填写一个名字</p><p>然后在 key 中粘贴刚刚复制的公钥</p><p><strong>验证连接</strong></p><p>打开 Git Bash，输入 <code>ssh -T git@github.com</code> 出现 “Are you sure……”，输入 yes 回车确认</p><p>显示 “Hi xxx! You’ve successfully……” 即连接成功。</p><h2 id="4-安装-nodejs"><a href="#4-安装-nodejs" class="headerlink" title="4. 安装 nodejs"></a>4. 安装 nodejs</h2><p>在这推荐使用 nvm 来管理 node 版本</p><p>安装之后, </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nvm list available<br></code></pre></td></tr></table></figure><p><img src="https://images.shadowzlh.top/2023/08/8bc0c442de2e2fd2debcc614035ea844.png" alt="nvm 查看可用 node"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">nvm install 18.17.1<br>nvm use 18.17.1<br></code></pre></td></tr></table></figure><p>之后 node 就可以使用了</p><h2 id="5-安装-hexo"><a href="#5-安装-hexo" class="headerlink" title="5. 安装 hexo"></a>5. 安装 hexo</h2><p>先新建一个专门管理博客的目录</p><p>然后在这个目录中打开 cmd</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install -g hexo-cli <br></code></pre></td></tr></table></figure><p>之后我们就可以调用 hexo 的命令了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo init<br></code></pre></td></tr></table></figure><p>初始化一个博客的目录</p><p>之后我们可以安装hexo 的部署插件, 这个插件是帮助我们部署到远程仓库的 github pages 服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install hexo-deployer-git --save<br></code></pre></td></tr></table></figure><p>此时, 在这个地方打开git bash 执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo g &amp; hexo s<br></code></pre></td></tr></table></figure><p>就可以在本地预览一下 本地地址 <code>http://localhost:4000</code></p><p>就可以看到 hexo 的默认主题了</p><p><img src="https://images.shadowzlh.top/2023/08/7bcf2f5a13ce799c4cab3b538fc042a7.png" alt="hexo 初始主题"></p><p>此时我们需要进入  <code>_config.yml</code> 文件</p><p>然后修改这里的文件</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">deploy:</span><br><span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br><span class="hljs-attr">repo:</span> <span class="hljs-string">这里填入你之前在GitHub上创建仓库的完整路径，记得加上</span> <span class="hljs-string">.git</span><br><span class="hljs-attr">branch:</span> <span class="hljs-string">master</span><br></code></pre></td></tr></table></figure><p>配置远程的仓库</p><p>之后我们就可以 <code>hexo d</code> 推送到远程的 github pages 服务</p><h2 id="6-更换主题"><a href="#6-更换主题" class="headerlink" title="6. 更换主题"></a>6. 更换主题</h2><p>我这里使用的是 fluid 主题</p><h4 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h4><p>Hexo 5.0.0 版本以上，推荐通过 npm 直接安装，进入博客目录执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install --save hexo-theme-fluid<br></code></pre></td></tr></table></figure><p>然后在博客目录下创建 <code>_config.fluid.yml</code>，将主题的 config.yml 内容复制过去。</p><h4 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h4><p>下载 <a href="https://github.com/fluid-dev/hexo-theme-fluid/releases">最新 release 版本 (opens new window)</a>解压到 themes 目录，并将解压出的文件夹重命名为 <code>fluid</code>。</p><p>然后再_config.yml 中将主题修改为 fluid</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">theme:</span> <span class="hljs-string">fluid</span>  <span class="hljs-comment"># 指定主题</span><br><br><span class="hljs-attr">language:</span> <span class="hljs-string">zh-CN</span>  <span class="hljs-comment"># 指定语言，会影响主题显示的语言，按需修改</span><br></code></pre></td></tr></table></figure><h2 id="7-绑定域名"><a href="#7-绑定域名" class="headerlink" title="7.  绑定域名"></a>7.  绑定域名</h2><p>首先进入自己的域名服务商管理, 配置一下自己的 DNS</p><p><img src="https://images.shadowzlh.top/2023/08/ae3364b97cdbaa46ee3d12c121b3e614.png" alt="image-20230828142145711"></p><p>将自己的顶级域名指向github 的https 推荐的地址</p><p>以下任何一个都可以</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">185.199.108.153<br>185.199.109.153<br>185.199.110.153<br>185.199.111.153<br></code></pre></td></tr></table></figure><p>之后点击github 仓库 的 setting -&gt; pages</p><p><img src="https://images.shadowzlh.top/2023/08/22373def1926b586701725de1511662f.png" alt="image-20230828142429027"></p><p>在这里配置自己的顶级域名就可以, 然后打开https就行</p><p>如果你的域名服务商是Cloudflare 不要开启代理</p><p>否则会出现一点问题</p><p>之后可以就通过域名访问你的博客了</p>]]></content>
    
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OAuth2.0</title>
    <link href="/2023/08/26/OAuth2-0/"/>
    <url>/2023/08/26/OAuth2-0/</url>
    
    <content type="html"><![CDATA[<h2 id="OAuth2-0"><a href="#OAuth2-0" class="headerlink" title="OAuth2.0"></a>OAuth2.0</h2><h3 id="1-OAuth2-是什么"><a href="#1-OAuth2-是什么" class="headerlink" title="1. OAuth2 是什么"></a>1. OAuth2 是什么</h3><blockquote><p>含义</p></blockquote><p><code>OAuth2.0</code>是<code>OAuth</code>协议的延续版本，但不向前兼容<code>OAuth 1.0</code>(即完全废止了<code>OAuth1.0</code>)。 <code>OAuth 2.0</code>关注客户端开发者的简易性。要么通过组织在资源拥有者和HTTP服务商之间的被批准的交互动作代表用户，要么允许第三方应用代表用户获得访问的权限。同时为Web应用，桌面应用和手机，和起居室设备提供专门的认证流程</p><h3 id="2-OAuth2-的四种角色"><a href="#2-OAuth2-的四种角色" class="headerlink" title="2. OAuth2 的四种角色"></a>2. OAuth2 的四种角色</h3><ol><li>资源所有者(Resource Owner) : 即用户本身</li><li>资源服务器(Resource Server) : 存储受保护的账号信息</li><li>授权服务器(Authorization Server) : 在成功验证用户身份, 并获得授权后, 给客户端派发访问令牌</li><li>客户端(Client) : 即代表你访问的第三方应用</li></ol><h3 id="3-OAuth2-的四种模式"><a href="#3-OAuth2-的四种模式" class="headerlink" title="3.OAuth2 的四种模式"></a>3.OAuth2 的四种模式</h3><blockquote><p>授权码模式 : 最常用的模式, 最繁琐的模式, 也是最安全的模式</p></blockquote><p><img src="https://images.shadowzlh.top/2023/08/ae7bd889b2bb393719f3f29294b85def.png" alt="image-20230826212742387"></p><p><strong>流程: 也可以把访问照片理解成为，登录第三方应用</strong></p><ul><li>1.2.3：用户通过浏览器访问第三方应用(client)的一张照片，但浏览器没有权限</li><li>4：通过请求重定向至授权页面，等待用户授权</li><li>5.6：用户授权完成，授权服务器返回一个 code 和 client_id 给浏览器</li><li>7.8.9:浏览器拿着code去请求client，client拿着code去和授权服务器换取<a href="https://so.csdn.net/so/search?q=Access_token&spm=1001.2101.3001.7020">Access_token</a>和 Refresh_token  </li><li>10.11: client拿着Access_token去和资源服务器换取照片信息,资源服务器验证access_Token的合法性，没问题就允许访问可控资源，返回照片列表给client</li><li>12.13: client拿到照片列表给到浏览器，浏览器返回视图给用户看</li></ul><blockquote><p>简化模式</p></blockquote><p>简化模式相比于授权码模式，少了code换取token这一步，但不安全，token可以被恶意脚本获取，同时token有效期短，浏览器关闭即失效。</p><p><img src="https://images.shadowzlh.top/2023/08/2b8a9aecaf8c2bb77fb46f1c8a71750c.png" alt="image-20230826212819435"></p><blockquote><p>密码模式 </p></blockquote><p>密码模式是用户直接将自己的用户名密码交给client（App），client用用户的用户名密码直接换取AccessToken。</p><blockquote><p>客户端模式</p></blockquote><p>只要client请求，我们就将AccessToken发送给它。</p><p>转载: <a href="https://blog.csdn.net/Huang_Ds/article/details/125533523">【OAuth2】详细讲解_Huang_Ds的博客-CSDN博客</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OAUth</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
